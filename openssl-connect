#!/bin/bash
# Connects to a SSL host for a list of ciphers
# Author: Peter Wu <lekensteyn@gmail.com>

host=${1:-localhost}
portbase=${2:-4430}

s_client_client_random() {
    awk '
    # match Master-Key from SSL Session dump
    /Master-Key:/{key=$2}

    # start matching bytes when requested
    l > 0 {
        b=1;e=16;
        if(l==3)b=7;
        if(l==1)e=6;
        for (i = b; i <= e; i++)
            s=s$i;

        # at the end, save random value in map r
        if (l--==1)
            queued[s] = 1;
    }

    # Match block containing Crandom bytes (over three lines)
    / ClientHello|ServerHello$/{l=3;s=""}

    # whenever a key and random is available, print it. This allows the random
    # to be known before the connection is finished.
    key {
        for (rnd in queued) {
            has_random = 1;
            print "CLIENT_RANDOM", rnd, key
            delete queued[rnd];
        }
        fflush();
    }

    END {
        for (rnd in queued) {
            print "# No master key for random", rnd
        }
        # should not be possible since the first thing we sent out is a
        # ClientHello, but just to be sure...
        if (!has_random) {
            if (key)
                print "# No random found for key", key
            else
                print "# No random nor key found"
        }
    }'
}

# When stdin is a TTY, try all ciphers
if [ -t 0 ]; then
    openssl ciphers -V
else
    # otherwise if not TTY, pass-through (useful for grep)
    cat
fi |
awk '# Look for something like ECDHE-RSA-AES256-SHA
{
    for (i = 1; i <= NF; i++) {
        if ($i ~ /.-./) {
            print $i;
            break
        }
    }
}' |
while read cipher; do
    case $cipher in
    *-ECDSA-*)
        port=$((portbase+1)) ;;
    ECDH-RSA-*)
        port=$((portbase+2)) ;;
    *-DSS-*)
        port=$((portbase+3)) ;;
    PSK-*)
        echo "Skipping unsupported PSK" >&2
        continue
        ;;
    *-RSA-*|*) # assume RSA (includes name like RC4-SHA)
        port=$portbase ;;
    esac

    echo "# Cipher Suite $cipher"

    # It is expected that the other side closes the connection
    printf "GET / HTTP/1.0\r\n\r\n" |
    openssl s_client -connect "$host:$port" -ign_eof -cipher "$cipher" \
        -msg 2>&1 | s_client_client_random
done

# vim: set et sw=4 ts=4:
